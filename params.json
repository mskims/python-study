{
  "name": "Python-study",
  "tagline": "",
  "body": "# 파이썬\r\n\r\n[](https://wikidocs.net/images/page/5/pahkey_KRRKrp.png)\r\n\r\n> 1991년 귀도 반 로섬이 발표한 C기반의 객체 지향적 대화형 프로그래밍 언어 이다.\r\n\r\n## 특징\r\n\r\n* 간결하고 쉬운 (직관적인) 문법\r\n* 빠른 개발 속도\r\n* 오픈소스\r\n\r\n### 간결하고 쉬운 문법\r\n\r\n```\r\nprint 'hello world!'\r\n```\r\n\r\n파이썬에서 hello world 를 출력하기 위한 코드는 단 한줄!\r\n\r\n### 사라진 세미콜론\r\n\r\n파이썬의 가장 큰 특징 중 하나가 생소한 문법이다.\r\n\r\n파이썬은 다른 보편적인 언어와 달리 명령어 끝에 세미콜론을 쓰지 않는다.\r\n\r\n아 물론 세미콜론을  붙여도 문제없이 동작 하지만 파이썬이 공식으로 제공하는 코드 컨벤션인 PEP가 경고한다. \r\n\r\n```\r\nprint 'Where is semicolon?'\r\n```\r\n\r\n### 들여쓰기 scope\r\n\r\n```\r\n# Python\r\nif Condition:\r\n\tdo_something()\r\n// JS\r\nif(condition){\r\n\tdo_something()\r\n}\r\n```\r\n\r\n파이썬의 코드블럭이다.\r\n\r\n이 해괴 망측한 문법은 코드블럭을 { }  로 구분하는 대신 가독성이 뛰어나다는 이유로 들여쓰기로 구분한다. 쓰다보니 편하네요.\r\n\r\n### PEP8\r\n\r\n파이썬이 제공하는 PEP라는 코드 스타일 가이드이다.\r\n\r\n다른 언어로 짜여진 프로젝트들을 보면 코드 스타일이 다르지만 파이썬은 엄격하게 가이드라인을 만들어 제시하고 있다.\r\n\r\n1. 들여쓰기는 공백 4칸을 권장합니다.\r\n2. 한줄은 최대 79자까지 (????)\r\n3. 최상위(top-level) 함수와 클래스 정의는 2줄씩 띄어 씁니다.\r\n4. 클래스 내의 메소드 정의는 1줄씩 띄어 씁니다.\r\n\r\n파이참은 칼같이 이 가이드라인을 지킨다.\r\n우리 모두 지켜 씁시다. \r\n\r\n## 자료형\r\n### 숫자형\r\n\r\n```\r\na = 1\r\n```\r\n\r\n평범하다.\r\n\r\n### 문자열\r\n\r\n```\r\na = 'this is string'\r\n```\r\n\r\n#### 문자열 내장함수\r\n\r\n문자열은 많은 함수를 가지고 있다.\r\n\r\n''capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'......\r\n\r\n그중 몇개를 자세히 알아보자.\r\n\r\n```\r\na = 'Hello String'\r\na.upper(), a.lower()\t# 'HELLO STRING', 'hello string'\r\n'i am min seok kim'.title\t# 'I Am Min Seok Kim'\r\n```\r\n\r\n파이썬에서 자주 쓰이는 String.format 함수를 알아보자.\r\n\r\n```\r\n'I am {}'.format('Babo')\t# 'I am Babo'\r\n'I love {0} and {1}'.format('you', 'me')\t# I love you and me\r\n'{s} {v} {o}'.format(s='Modernize', v='Your', o='DBMS')\t# Modernize Your DBMS\r\n\r\n'{s} {v} {o}'.format({ 's': 'Mordernize', 'v': 'Your', 'o': 'DBMS' })\t# KeyError: 's'\r\n```\r\n\r\n### 튜플\r\n\r\n파이썬은 튜플이란 이상한 데이터 형태를 가지고있다.\r\n\r\n#### 기본형태\r\n\r\n```\r\na = 1\r\nb = 2\r\ntuple = a, b\r\nprint tuple\t\t# (1, 2)\r\n```\r\n\r\n이런것도 가능하다\r\n\r\n```\r\na, b = 1, 2\r\na # 1\r\nb # 2\r\n```\r\n\r\n```\r\ndef func(a, b):\r\n\treturn a + b\r\ntuple = 1, 2\r\nprint func(*tuple)\t# 3\r\n```\r\n\r\nㅎㄷㄷ\r\n\r\n### 딕셔너리\r\n\r\n```\r\na = {\r\n\t'key': 'value',\r\n\t'key2': 'value2'\r\n}\r\n# 이렇게 선언할 수도 있다.\r\nb = dict(\r\n\tkey='value',\r\n\tkey2='value2'\r\n)\r\n```\r\n\r\n보기엔 JSON 과 유사해보인다.\r\n\r\n딕셔너리는 키와 값 한쌍을 갖는 데이터 집합이다.\r\n\r\n키는 중복될 수 없으며 키값이 중복되있으면 한 값만 남는데, 보통 뒤에 선언된 값이 남는다.\r\n\r\n항상 그렇다는건 아니다. 중복되게 쓰지 마세요.\r\n\r\n```\r\na = {\r\n\t'key': 'value',\r\n\t'key': 'value?'\r\n}\r\na\t# { 'key': 'value?' }\r\n```\r\n\r\n#### 주소 참조\r\n\r\n딕셔너리의 복사에 대해 이야기 해보자.\r\n\r\n딕셔너리의 복사는 2종류가 있는데 코드로 봅시다.\r\n\r\n```\r\na = {\r\n\t'key': 'value',\r\n\t'key2': 'value2'\r\n}\r\nb = a\r\ndel b['key2']\r\nprint a\r\n```\r\n\r\nprint a 의 결과값은 { 'key': 'value' } 이다.\r\n\r\n일반 대입식처럼 딕셔너리를 새로운 변수에 대입했을 경우엔 값을 복사하는게 아니고 딕셔너리의 주소를 복사하게 된다. \r\n\r\n포인터랑 비슷하다고 보면 된다.\r\n\r\n값 자체를 복사해서 새로운 딕셔너리 객체를 만들고 싶으면 copy() 내장 함수를 사용하면 된다.\r\n\r\n```\r\na = {\r\n\t'key': 'value',\r\n\t'key2': 'value2'\r\n}\r\nb = a.copy()\r\ndel b['key2']\r\nprint a # { 'key': 'value', 'key2': 'value2' }\r\nprint b # { 'key': 'value' }\r\n```\r\n\r\n#### 딕셔너리 제어\r\n\r\n```\r\na = {\r\n\t'key': 'value',\r\n\t'key2': 'value2'\r\n}\r\n# 삭제\r\ndel a['key']\r\na\t# { 'key2': 'value2' }\r\n```\r\n\r\n#### 반복문 적용하기\r\n\r\n딕셔너리 객체 (파이썬에선 모든것이 객체이다) 는 keys, values, items... 함수를 프로토타입으로 가지고있다.\r\n\r\n* (Dict).keys() 함수는 딕셔너리의 키들을 리스트 형태로 반환한다.\r\n* (Dict).values() 함수는 딕셔너리의 값들을 리스트 형태로 반환한다.\r\n* (Dict).items() 함수는 딕셔너리의 키,밸류 쌍을 튜플로 묶어 리스트 형태로 반환한다.\r\n\r\n```\r\na = {\r\n\t'key': 'value',\r\n\t'key2': 'value2'\r\n}\r\na.keys()\t# ['key', 'key2']\r\na.values()\t# ['value', 'value1']\r\na.items()\t# [('key', 'value'), ('key2', 'value2')]\r\n```\r\n\r\n여기서 주의해야 할 점이 있다. 이 책에선 파이썬 2버전으로 예제를 쓰고있지만 3버전 같은 경우엔 다르기 때문에 주의해야 한다.\r\n\r\n파이썬 2.7 버전 까지는 keys, values, items 함수는 리스트 형태로 반환을 했지만 3.0 버전부터는 메모리 낭비의 이유로 리스트 객체가 아닌 이터러블(반복가능)한 객체를 반환해준다.\r\n\r\n리스트는 아니기때문에 직접 접근할 수는 없지만 이터러블한 객체기때문에 반복문에 넣어도 아무 문제가 없고 메모리문제도 개선되어 성능을 향상시킬 수 있다.\r\n\r\n```\r\n# in python 3\r\na = {\r\n\t'key': 'value',\r\n\t'key2': 'value2'\r\n}\r\na.keys()\t// dict_keys(['key2', 'key'])\r\na.values()\r\na.items()\r\nfor key in a.keys():\r\n\tprint(key)\r\n```\r\n\r\n#### 딕셔너리 리터럴/함수 선언 방식 퍼포먼스 비교\r\n\r\n```\r\n$ python -m timeit \"d=dict(prop='val')\"\r\n10000000 loops, best of 3: 0.219 usec per loop\r\n$ python -m timeit \"d={'prop': 'val'}\"\r\n10000000 loops, best of 3: 0.075 usec per loop\r\n\r\n$ python3 -m timeit \"d = dict(prop='val')\"\r\n1000000 loops, best of 3: 0.475 usec per loop\r\n$ python3 -m timeit \"d = {'prop': 'val'}\"\r\n10000000 loops, best of 3: 0.143 usec per loop\r\n```\r\n\r\n리터럴 선언 방식이 더 빠르다.\r\n\r\n### 집합\r\n## 제어문\r\n### if\r\n\r\n```\r\nif condition:\r\n\tprint 'Oh its true'\r\n\r\ntFlag, fFlag = True, False\r\nif not fFlag:\t# if fFlag != True\r\n\tprint '!'\r\nelif tFlag:\t\t# else if tFlag == true\r\n\tprint '!!'\r\nelse:\r\n\tprint '..'\r\n```\r\n\r\n### while\r\n\r\n```\r\nwhile condition:\r\n\tdo_something()\r\n\tif condition:\r\n\t\tbreak\t# 반복문 종료\r\n\telif condition:\r\n\t\tcontinue\t# 현재 반복 종료 (다음 반복으로 넘어감)\r\n```\r\n\r\n### for\r\n\r\n```\r\nfor value in ITERABLE_VARIABLE:\r\n\tprint value\r\n\r\nfor i in [1, 2, 3, 4, 5]:\r\n\tprint value \r\n# 1\r\n# 2\r\n# ...\r\nd = {\r\n\t'key': '11',\r\n\t'key2': '22'\r\n}\r\nfor key in d:\r\n\tprint key\r\n# key\r\n# key2\r\nfor key, value in d:\r\n\tprint key, value\r\n```\r\n\r\n### switch\r\n파이썬은 공식적으로 switch/case 문을 지원하지 않는다. 이유는 잘 모르겠다\r\n추가 바람\r\n\r\n## 핵심 기능\r\n\r\n### 클래스, 모듈\r\n\r\n### 패키지\r\n\r\n### 예외\r\n\r\n### 익명함수 (람다)\r\n\r\n### dunder variables\r\n\r\n## 카드놀이\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}